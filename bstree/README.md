<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# bstree

```go
import "github.com/esimov/torx/bstree"
```

Package bstree provides an implementation of the Binary Search Tree \(BST\) data structure algorithm, where each node has at most two child nodes and the key of its internal node is greater than all the keys in the respective node's left subtree and less than the ones in the right subtree.

## Index

- [Variables](<#variables>)
- [type BsTree](<#type-bstree>)
  - [func New[K constraints.Ordered, V any](comp torx.CompFn[K]) *BsTree[K, V]](<#func-new>)
  - [func (b *BsTree[K, V]) Delete(key K) error](<#func-bstreek-v-delete>)
  - [func (b *BsTree[K, V]) Get(key K) (Item[K, V], error)](<#func-bstreek-v-get>)
  - [func (b *BsTree[K, V]) Size() int](<#func-bstreek-v-size>)
  - [func (b *BsTree[K, V]) Traverse(fn func(Item[K, V]))](<#func-bstreek-v-traverse>)
  - [func (b *BsTree[K, V]) Upsert(key K, val V)](<#func-bstreek-v-upsert>)
- [type Item](<#type-item>)
- [type Node](<#type-node>)
  - [func NewNode[K constraints.Ordered, V any](key K, val V) *Node[K, V]](<#func-newnode>)
  - [func (n *Node[K, V]) delete(b *BsTree[K, V], key K) (*Node[K, V], error)](<#func-nodek-v-delete>)
  - [func (n *Node[K, V]) get(b *BsTree[K, V], key K) (Item[K, V], error)](<#func-nodek-v-get>)
  - [func (n *Node[K, V]) min() *Node[K, V]](<#func-nodek-v-min>)
  - [func (n *Node[K, V]) traverse(b *BsTree[K, V], ch chan<- Item[K, V])](<#func-nodek-v-traverse>)
  - [func (n *Node[K, V]) upsert(b *BsTree[K, V], key K, val V)](<#func-nodek-v-upsert>)


## Variables

```go
var ErrorNotFound = fmt.Errorf("BST node not found")
```

## type BsTree

BsTree is the basic component for the BST data structure initialization. It incorporates a thread safe mechanism using the sync.Mutex to guarantee the data consistency on concurrent read and write operation.

```go
type BsTree[K constraints.Ordered, V any] struct {
    mu   *sync.RWMutex
    comp torx.CompFn[K]
    root *Node[K, V]
    size int
}
```

### func New

```go
func New[K constraints.Ordered, V any](comp torx.CompFn[K]) *BsTree[K, V]
```

New initializes a new BST data structure together with a comparison operator. Depending on the comparator it sorts the tree in ascending or descending order.

### func \(\*BsTree\[K, V\]\) Delete

```go
func (b *BsTree[K, V]) Delete(key K) error
```

Delete removes a node defined by its key from the tree structure.

### func \(\*BsTree\[K, V\]\) Get

```go
func (b *BsTree[K, V]) Get(key K) (Item[K, V], error)
```

Get retrieves the node item and an error in case the requested node does not exists.

### func \(\*BsTree\[K, V\]\) Size

```go
func (b *BsTree[K, V]) Size() int
```

Size returns the size of the tree.

### func \(\*BsTree\[K, V\]\) Traverse

```go
func (b *BsTree[K, V]) Traverse(fn func(Item[K, V]))
```

Traverse iterates over the tree structure and invokes the callback function provided as a parameter.

### func \(\*BsTree\[K, V\]\) Upsert

```go
func (b *BsTree[K, V]) Upsert(key K, val V)
```

Upsert insert a new node, or update an existing node in case the key is found in the tree list.

## type Item

Item contains the node's data as a key\-value pair data structure.

```go
type Item[K constraints.Ordered, V any] struct {
    Key K
    Val V
}
```

## type Node

Node represents the BST internal Node, having as components the Node item defined as a key\-value pair and two separate pointers to the left and right child nodes.

```go
type Node[K constraints.Ordered, V any] struct {
    Left  *Node[K, V]
    Right *Node[K, V]
    Item[K, V]
}
```

### func NewNode

```go
func NewNode[K constraints.Ordered, V any](key K, val V) *Node[K, V]
```

NewNode creates a new node.

### func \(\*Node\[K, V\]\) delete

```go
func (n *Node[K, V]) delete(b *BsTree[K, V], key K) (*Node[K, V], error)
```

### func \(\*Node\[K, V\]\) get

```go
func (n *Node[K, V]) get(b *BsTree[K, V], key K) (Item[K, V], error)
```

### func \(\*Node\[K, V\]\) min

```go
func (n *Node[K, V]) min() *Node[K, V]
```

min searches for the latest node on the left branch, but considering that BST is an ordered tree data structure it happens that it holds also the smallest value.

### func \(\*Node\[K, V\]\) traverse

```go
func (n *Node[K, V]) traverse(b *BsTree[K, V], ch chan<- Item[K, V])
```

### func \(\*Node\[K, V\]\) upsert

```go
func (n *Node[K, V]) upsert(b *BsTree[K, V], key K, val V)
```



