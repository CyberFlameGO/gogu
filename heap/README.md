<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# heap

```go
import "github.com/esimov/gogu/heap"
```

Package heap provides a thread\-safe implementation of the binary heap data structure. A common implementation of the heap is the binary tree, where each node of the subtree satisfies the heap property: each node of the subtree is greater or equal then the parent node in case of min heap, and less or equal than the parent node in case of max heap. The conditional operator used on the heap initialization defines the heap type

<details><summary>Example</summary>
<p>

```go
{
	data := []int{1, 3, 2, 8, 7, 6, 4, 9, 5, 10}

	res := Sort(data, func(a, b int) bool { return a > b })
	fmt.Println(res)

	res = Sort(data, func(a, b int) bool { return a < b })
	fmt.Println(res)

}
```

#### Output

```
[1 2 3 4 5 6 7 8 9 10]
[10 9 8 7 6 5 4 3 2 1]
```

</p>
</details>

<details><summary>Example (Convert)</summary>
<p>

```go
{
	input := []int{1, 4, 2, 3, 5}

	heap := NewHeap(func(a, b int) bool { return a < b })
	heap.Push(input...)
	heap.Convert(func(a, b int) bool { return a > b })
	fmt.Println(heap.GetValues())

}
```

#### Output

```
[5 4 2 1 3]
```

</p>
</details>

<details><summary>Example (Max Heap)</summary>
<p>

```go
{
	values := []int{9, 3, 20, 8, 6, 5, 12, 10, 9, 18}
	heap := FromSlice(values, func(a, b int) bool { return a > b })
	fmt.Println(heap.GetValues())

	ok, _ := heap.Delete(12)
	fmt.Println(ok)
	fmt.Println(heap.Size())

	heap.Clear()
	fmt.Println(heap.GetValues())

	input := []int{20, 18, 10, 9, 9, 8, 6, 5, 3}
	heap.Push(input...)

	popSlice := []int{}
	for range heap.GetValues() {
		val := heap.Pop()
		popSlice = append(popSlice, val)
	}
	fmt.Println(popSlice)

}
```

#### Output

```
[20 18 12 10 6 5 9 8 9 3]
true
9
[]
[20 18 10 9 9 8 6 5 3]
```

</p>
</details>

<details><summary>Example (Meld)</summary>
<p>

```go
{
	slice1 := []int{1, 4, 2, 3, 5}
	slice2 := []int{8, 6, 9, 10, 7}

	heap1 := FromSlice(slice1, func(a, b int) bool { return a < b })
	heap2 := FromSlice(slice2, func(a, b int) bool { return a < b })

	mergedHeap := heap1.Meld(heap2)
	fmt.Println(mergedHeap.Size())
	fmt.Println(heap1.Size())
	fmt.Println(heap2.Size())

}
```

#### Output

```
10
0
0
```

</p>
</details>

<details><summary>Example (Merge)</summary>
<p>

```go
{
	slice1 := []int{1, 4, 2, 3, 5}
	slice2 := []int{8, 6, 9, 10, 7}

	heap1 := FromSlice(slice1, func(a, b int) bool { return a < b })
	heap2 := FromSlice(slice2, func(a, b int) bool { return a < b })

	mergedHeap := heap1.Merge(heap2)
	fmt.Println(mergedHeap.Size())
	fmt.Println(heap1.Size())
	fmt.Println(heap2.Size())

}
```

#### Output

```
10
5
5
```

</p>
</details>

<details><summary>Example (Min Heap)</summary>
<p>

```go
{
	heap := NewHeap(func(a, b int) bool { return a < b })
	fmt.Println(heap.IsEmpty())

	heap.Push(10)
	fmt.Println(heap.Size())
	heap.Pop()
	fmt.Println(heap.IsEmpty())

	values := []int{2, 5, 1, 4, 3}
	for _, v := range values {
		heap.Push(v)
	}
	fmt.Println(heap.GetValues())

	heap.Push(0)
	fmt.Println(heap.GetValues())

	heap.Clear()
	fmt.Println(heap.GetValues())

	fmt.Println(heap.Pop())

	heap.Push(10, 4, 2, 5, 3)
	for range heap.GetValues() {
		heap.Pop()
	}
	fmt.Println(heap.Size())

}
```

#### Output

```
true
1
true
[1 3 2 5 4]
[0 3 1 5 4 2]
[]
0
0
```

</p>
</details>

## Index

- [func Sort[T comparable](data []T, comp gogu.CompFn[T]) []T](<#func-sort>)
- [type Heap](<#type-heap>)
  - [func FromSlice[T comparable](data []T, comp gogu.CompFn[T]) *Heap[T]](<#func-fromslice>)
  - [func NewHeap[T comparable](comp gogu.CompFn[T]) *Heap[T]](<#func-newheap>)
  - [func (h *Heap[T]) Clear()](<#func-heapt-clear>)
  - [func (h *Heap[T]) Convert(comp gogu.CompFn[T])](<#func-heapt-convert>)
  - [func (h *Heap[T]) Delete(val T) (bool, error)](<#func-heapt-delete>)
  - [func (h *Heap[T]) GetValues() []T](<#func-heapt-getvalues>)
  - [func (h *Heap[T]) IsEmpty() bool](<#func-heapt-isempty>)
  - [func (h *Heap[T]) Meld(h2 *Heap[T]) *Heap[T]](<#func-heapt-meld>)
  - [func (h *Heap[T]) Merge(h2 *Heap[T]) *Heap[T]](<#func-heapt-merge>)
  - [func (h *Heap[T]) Peek() T](<#func-heapt-peek>)
  - [func (h *Heap[T]) Pop() T](<#func-heapt-pop>)
  - [func (h *Heap[T]) Push(val ...T)](<#func-heapt-push>)
  - [func (h *Heap[T]) Size() int](<#func-heapt-size>)


## func [Sort](<https://github.com/esimov/gogu/blob/master/heap/heapsort.go#L17>)

```go
func Sort[T comparable](data []T, comp gogu.CompFn[T]) []T
```

Sort sorts the heap in ascending or descending order depending on the heap type. In case the heap is a max heap, the heap is sorted in ascending order, otherwise in descending order.

## type [Heap](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L18-L22>)

```go
type Heap[T comparable] struct {
    // contains filtered or unexported fields
}
```

### func [FromSlice](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L160>)

```go
func FromSlice[T comparable](data []T, comp gogu.CompFn[T]) *Heap[T]
```

FromSlice imports the slice elements into a new heap using the comparator function.

### func [NewHeap](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L27>)

```go
func NewHeap[T comparable](comp gogu.CompFn[T]) *Heap[T]
```

NewHeap creates a new heap data structure having two components: a data slice holding the concrete values and a comparison function. The sign of the comparison function defines if we are dealing with a min or max heap.

### func \(\*Heap\[T\]\) [Clear](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L57>)

```go
func (h *Heap[T]) Clear()
```

Clear removes all the elements from the heap.

### func \(\*Heap\[T\]\) [Convert](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L148>)

```go
func (h *Heap[T]) Convert(comp gogu.CompFn[T])
```

Convert converts a min heap to max heap and vice versa.

### func \(\*Heap\[T\]\) [Delete](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L126>)

```go
func (h *Heap[T]) Delete(val T) (bool, error)
```

Delete removes an element from the heap. It returns false in case the element does not exists. After removal, it reorders the heap structure based on the heap\-specific rules.

### func \(\*Heap\[T\]\) [GetValues](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L86>)

```go
func (h *Heap[T]) GetValues() []T
```

GetValues returns the heap values.

### func \(\*Heap\[T\]\) [IsEmpty](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L49>)

```go
func (h *Heap[T]) IsEmpty() bool
```

IsEmpty checks if the heap is empty or not.

### func \(\*Heap\[T\]\) [Meld](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L210>)

```go
func (h *Heap[T]) Meld(h2 *Heap[T]) *Heap[T]
```

Meld merge two heaps into a new one containing all the elements of both and destroying the original ones.

### func \(\*Heap\[T\]\) [Merge](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L194>)

```go
func (h *Heap[T]) Merge(h2 *Heap[T]) *Heap[T]
```

Merge joins two heaps into a new one preserving the original ones.

### func \(\*Heap\[T\]\) [Peek](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L69>)

```go
func (h *Heap[T]) Peek() T
```

Peek returns the first element of the heap. This can be the minimum or maximum value depending on the heap type.

### func \(\*Heap\[T\]\) [Pop](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L107>)

```go
func (h *Heap[T]) Pop() T
```

Pop removes the first element from the heap and reorder the existing elements. The removed element is the minimum or maximum depending on the heap type.

### func \(\*Heap\[T\]\) [Push](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L95>)

```go
func (h *Heap[T]) Push(val ...T)
```

Push inserts new elements at the end of the heap and calls the heapify algorithm to reorder the existing elements in ascending or descending order, depending on the heap type.

### func \(\*Heap\[T\]\) [Size](<https://github.com/esimov/gogu/blob/master/heap/heap.go#L36>)

```go
func (h *Heap[T]) Size() int
```

Size returns the heap size.



