<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# heap

```go
import "github.com/esimov/torx/heap"
```

## Index

- [func Sort[T comparable](data []T, comp torx.CompFn[T]) []T](<#func-sort>)
- [func swap[T any](data []T, i, j int)](<#func-swap>)
- [type Heap](<#type-heap>)
  - [func FromSlice[T comparable](data []T, comp torx.CompFn[T]) *Heap[T]](<#func-fromslice>)
  - [func NewHeap[T comparable](comp torx.CompFn[T]) *Heap[T]](<#func-newheap>)
  - [func (h *Heap[T]) Clear()](<#func-heapt-clear>)
  - [func (h *Heap[T]) Convert(comp torx.CompFn[T])](<#func-heapt-convert>)
  - [func (h *Heap[T]) Delete(val T) (bool, error)](<#func-heapt-delete>)
  - [func (h *Heap[T]) GetValues() []T](<#func-heapt-getvalues>)
  - [func (h *Heap[T]) IsEmpty() bool](<#func-heapt-isempty>)
  - [func (h *Heap[T]) Meld(h2 *Heap[T]) *Heap[T]](<#func-heapt-meld>)
  - [func (h *Heap[T]) Merge(h2 *Heap[T]) *Heap[T]](<#func-heapt-merge>)
  - [func (h *Heap[T]) Peek() T](<#func-heapt-peek>)
  - [func (h *Heap[T]) Pop() T](<#func-heapt-pop>)
  - [func (h *Heap[T]) Push(val ...T)](<#func-heapt-push>)
  - [func (h *Heap[T]) Size() int](<#func-heapt-size>)
  - [func (h *Heap[T]) getIndex(slice []T, val T) (int, bool)](<#func-heapt-getindex>)
  - [func (h *Heap[T]) leftChild(i int) int](<#func-heapt-leftchild>)
  - [func (h *Heap[T]) moveDown(n, i int)](<#func-heapt-movedown>)
  - [func (h *Heap[T]) moveUp(i int)](<#func-heapt-moveup>)
  - [func (h *Heap[T]) parent(i int) int](<#func-heapt-parent>)
  - [func (h *Heap[T]) rightChild(i int) int](<#func-heapt-rightchild>)


## func Sort

```go
func Sort[T comparable](data []T, comp torx.CompFn[T]) []T
```

Sort sorts the heap in ascending or descening order, depending on the heap type. If the heap is a max heap, the heap is sorted in ascending order, otherwise if the heap is a min heap, it is sorted in descending order.

## func swap

```go
func swap[T any](data []T, i, j int)
```

swap swaps the position of elements at index i and j.

## type Heap

```go
type Heap[T comparable] struct {
    mu   *sync.RWMutex
    data []T
    comp torx.CompFn[T]
}
```

### func FromSlice

```go
func FromSlice[T comparable](data []T, comp torx.CompFn[T]) *Heap[T]
```

FromSlice imports the slice elements into a new heap using the comparator function.

### func NewHeap

```go
func NewHeap[T comparable](comp torx.CompFn[T]) *Heap[T]
```

NewHeap creates a new heap data structure having two components: a data slice holding the concrete values and a comparision function. The comparator sign decides if the heap is a max heap or min heap.

### func \(\*Heap\[T\]\) Clear

```go
func (h *Heap[T]) Clear()
```

Clear removes all the elements from the heap.

### func \(\*Heap\[T\]\) Convert

```go
func (h *Heap[T]) Convert(comp torx.CompFn[T])
```

Convert a min heap to max heap and vice versa.

### func \(\*Heap\[T\]\) Delete

```go
func (h *Heap[T]) Delete(val T) (bool, error)
```

Delete removes an element from the heap. It returns false in case the element does not exists. After removal it reorders the heap based on the heap specific rules.

### func \(\*Heap\[T\]\) GetValues

```go
func (h *Heap[T]) GetValues() []T
```

GetValues returns the heap values.

### func \(\*Heap\[T\]\) IsEmpty

```go
func (h *Heap[T]) IsEmpty() bool
```

IsEmpty checks if the heap is empty or not.

### func \(\*Heap\[T\]\) Meld

```go
func (h *Heap[T]) Meld(h2 *Heap[T]) *Heap[T]
```

Meld merge two heaps into a new one containing all the elements of both and destroying the original ones.

### func \(\*Heap\[T\]\) Merge

```go
func (h *Heap[T]) Merge(h2 *Heap[T]) *Heap[T]
```

Merge joins two heaps into a new one preserving the original ones.

### func \(\*Heap\[T\]\) Peek

```go
func (h *Heap[T]) Peek() T
```

Peek returns the first element of the heap. This can be the minimum or maximum value depending on the heap type.

### func \(\*Heap\[T\]\) Pop

```go
func (h *Heap[T]) Pop() T
```

Pop removes the first element from the heap and reorder the existing elements. The removed element is the minimum or maximum depending on the heap type.

### func \(\*Heap\[T\]\) Push

```go
func (h *Heap[T]) Push(val ...T)
```

Push inserts new elements at the end of the heap and calls the heapify algorithm to reorder the existing elements in ascending or descending order, depending on the heap type.

### func \(\*Heap\[T\]\) Size

```go
func (h *Heap[T]) Size() int
```

Size returns the heap size.

### func \(\*Heap\[T\]\) getIndex

```go
func (h *Heap[T]) getIndex(slice []T, val T) (int, bool)
```

### func \(\*Heap\[T\]\) leftChild

```go
func (h *Heap[T]) leftChild(i int) int
```

leftChild returns the index of the left child of node at index i.

### func \(\*Heap\[T\]\) moveDown

```go
func (h *Heap[T]) moveDown(n, i int)
```

moveDown moves the element at the position i down to its correct position in the heap following the heap rules.

### func \(\*Heap\[T\]\) moveUp

```go
func (h *Heap[T]) moveUp(i int)
```

moveUp moves the element from index i up to its correct position in the heap following the heap rules.

### func \(\*Heap\[T\]\) parent

```go
func (h *Heap[T]) parent(i int) int
```

parent returns the index of the child node parent at index i.

### func \(\*Heap\[T\]\) rightChild

```go
func (h *Heap[T]) rightChild(i int) int
```

rightChild returns the index of the right child of node at index i.



