<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cache

```go
import "github.com/esimov/torx/cache"
```

Package cache implements a basic in memory key\-value storage system using map as storing mechanism. The cache and the cache items also have an expiration time. The cache will be invalidated once the expiration time is reached. On cache initialization a cleanup interval is also required. The scope of the cleanup method is to run at a predefined interval and remove all the expired cache items.

## Index

- [Constants](<#constants>)
- [type Cache](<#type-cache>)
  - [func New[T ~string, V any](expTime, cleanupTime time.Duration) *Cache[T, V]](<#func-new>)
- [type Item](<#type-item>)
  - [func (it *Item[V]) Val() V](<#func-itemv-val>)


## Constants

```go
const (
    NoExpiration      time.Duration = -1
    DefaultExpiration time.Duration = 0
)
```

## type Cache

Cache incorporates the local scope cache struct type.

```go
type Cache[T ~string, V any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example (Basic)</summary>
<p>

```go
{
	c := New[string, string](DefaultExpiration, 1*time.Minute)
	item, err := c.Get("foo")
	fmt.Println(err)
	fmt.Println(item)

	c.Set("foo", "bar", DefaultExpiration)
	item, err = c.Get("foo")
	fmt.Println(item.Val())

	err = c.Set("foo", "", DefaultExpiration)
	fmt.Println(err)
	fmt.Println(c.IsExpired("foo"))

	c.Update("foo", "baz", DefaultExpiration)
	item, _ = c.Get("foo")
	fmt.Println(item.Val())

	list := c.List()
	fmt.Println(len(list))

	c.Flush()
	fmt.Println(c.Count())

	c.Set("foo", "bar", DefaultExpiration)
	item, err = c.Get("foo")
	fmt.Println(item.Val())

	err = c.Delete("foo")
	fmt.Println(err)
	fmt.Println(c.Count())

}
```

#### Output

```
item with key 'foo' not found
<nil>
bar
item with key 'foo' already exists. Use the Update method
false
baz
1
0
bar
<nil>
0
```

</p>
</details>

<details><summary>Example (Expiration Time)</summary>
<p>

```go
{
	c1 := New[string, string](NoExpiration, 0)
	c1.Set("item1", "a", DefaultExpiration)
	item, _ := c1.Get("item1")
	fmt.Println(item.expiration)

	c1.Update("item1", "b", NoExpiration)
	item, _ = c1.Get("item1")
	fmt.Println(item.expiration)

	err := c1.DeleteExpired()
	fmt.Println(err)

	c1.Set("item1", "a", 1*time.Millisecond)
	<-time.After(2 * time.Millisecond)
	c1.DeleteExpired()
	fmt.Println(c1.Count())

	c1.Set("item1", "b", 1*time.Millisecond)
	c1.Set("item2", "b", 4*time.Millisecond)
	<-time.After(2 * time.Millisecond)
	c1.DeleteExpired()
	fmt.Println(c1.Count())

	<-time.After(3 * time.Millisecond)
	c1.DeleteExpired()
	fmt.Println(c1.Count())

	c2 := New[string, int](5*time.Millisecond, 1*time.Millisecond)
	c2.Set("a", 1, DefaultExpiration)
	c2.Set("b", 2, NoExpiration)
	c2.Set("c", 3, 5*time.Millisecond)
	c2.Set("d", 4, 20*time.Millisecond)
	<-time.After(10 * time.Millisecond)
	fmt.Println(c2.Count())
	<-time.After(15 * time.Millisecond)
	fmt.Println(c2.Count())

}
```

#### Output

```
0
0
<nil>
0
1
0
1
0
```

</p>
</details>

### func New

```go
func New[T ~string, V any](expTime, cleanupTime time.Duration) *Cache[T, V]
```

New instantiates a cache struct which requires an expiration time and a cleanup interval. The cache will be invalidated once the expiration time is reached. If the expiration time is less than zero \(or NoExpiration\) the cache items will never expire and should be manually deleted. A cleanup method is running in the background and removes the expired caches at a predifined interval.

## type Item

Item holds the cache object \(which could be of any type\) and an expiration time. The expiration time defines the object lifetime.

```go
type Item[V any] struct {
    // contains filtered or unexported fields
}
```

### func \(\*Item\[V\]\) Val

```go
func (it *Item[V]) Val() V
```

Val returns the effective value of the cache item.



