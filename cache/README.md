<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cache

```go
import "github.com/esimov/gogu/cache"
```

Package cache implements a basic in memory key\-value storage system using map as storing mechanism. The cache and the cache items also have an expiration time. The cache will be invalidated once the expiration time is reached. On cache initialization a cleanup interval is also required. The scope of the cleanup method is to run at a predefined interval and to remove all the expired cache items.

<details><summary>Example (Expiration Time)</summary>
<p>

```go
{
	c1 := New[string, string](NoExpiration, 0)
	c1.Set("item1", "a", DefaultExpiration)
	item, _ := c1.Get("item1")
	fmt.Println(item.expiration)

	c1.Update("item1", "b", NoExpiration)
	item, _ = c1.Get("item1")
	fmt.Println(item.expiration)

	err := c1.DeleteExpired()
	fmt.Println(err)

	c1.Set("item1", "a", 10*time.Millisecond)
	<-time.After(20 * time.Millisecond)
	c1.DeleteExpired()
	fmt.Println(c1.Count())

	c1.Set("item1", "b", 1*time.Millisecond)
	c1.Set("item2", "b", 50*time.Millisecond)
	<-time.After(20 * time.Millisecond)
	c1.DeleteExpired()
	fmt.Println(c1.Count())

	<-time.After(70 * time.Millisecond)
	c1.DeleteExpired()
	fmt.Println(c1.Count())

	c2 := New[string, int](5*time.Millisecond, 100*time.Millisecond)
	c2.Set("a", 1, DefaultExpiration)
	c2.Set("b", 2, NoExpiration)
	c2.Set("c", 3, 50*time.Millisecond)
	c2.Set("d", 4, 200*time.Millisecond)
	<-time.After(150 * time.Millisecond)
	fmt.Println(c2.Count())
	<-time.After(300 * time.Millisecond)
	fmt.Println(c2.Count())

}
```

#### Output

```
-1
-1
<nil>
1
2
1
2
1
```

</p>
</details>

<details><summary>Example (LRU Cache)</summary>
<p>

```go
{
	c, _ := NewLRU[string, string](3)
	item, available := c.Get("foo")
	fmt.Println(available)

	c.Add("foo", "bar")
	item, available = c.Get("foo")
	fmt.Println(available)
	fmt.Println(item)

	c.Add("foo2", "bar2")
	c.Add("foo3", "bar3")
	c.Add("foo4", "baz")

	fmt.Println(c.Count())
	fmt.Println()

	oldestKey, oldestValue, oldestAvailable := c.GetOldest()
	fmt.Println(oldestAvailable)
	fmt.Println(oldestKey)
	fmt.Println(oldestValue)
	fmt.Println()

	youngestKey, youngestValue, youngestAvailable := c.GetYoungest()
	fmt.Println(youngestAvailable)
	fmt.Println(youngestKey)
	fmt.Println(youngestValue)
	fmt.Println()

	oldestKey, oldestValue, oldestAvailable = c.RemoveOldest()
	fmt.Println(oldestAvailable)
	fmt.Println(oldestKey)
	fmt.Println(oldestValue)
	fmt.Println()

}
```

#### Output

```
false
true
bar
3

true
foo2
bar2

true
foo2
bar2

true
foo3
bar3
```

</p>
</details>

## Index

- [Constants](<#constants>)
- [type Cache](<#type-cache>)
  - [func New[T ~string, V any](expTime, cleanupTime time.Duration) *Cache[T, V]](<#func-new>)
  - [func (c *Cache[T, V]) Count() int](<#func-cachet-v-count>)
  - [func (c *Cache[T, V]) Delete(key T) error](<#func-cachet-v-delete>)
  - [func (c *Cache[T, V]) Flush()](<#func-cachet-v-flush>)
  - [func (c *Cache[T, V]) Get(key T) (*Item[V], error)](<#func-cachet-v-get>)
  - [func (c *Cache[T, V]) IsExpired(key T) bool](<#func-cachet-v-isexpired>)
  - [func (c *Cache[T, V]) List() map[T]*Item[V]](<#func-cachet-v-list>)
  - [func (c *Cache[T, V]) MapToCache(m map[T]V, d time.Duration) error](<#func-cachet-v-maptocache>)
  - [func (c *Cache[T, V]) Set(key T, val V, d time.Duration) error](<#func-cachet-v-set>)
  - [func (c *Cache[T, V]) SetDefault(key T, val V) error](<#func-cachet-v-setdefault>)
  - [func (c *Cache[T, V]) Update(key T, val V, d time.Duration) error](<#func-cachet-v-update>)
- [type Item](<#type-item>)
  - [func (it *Item[V]) Val() V](<#func-itemv-val>)
- [type LRUCache](<#type-lrucache>)
  - [func NewLRU[K comparable, V any](size int) (*LRUCache[K, V], error)](<#func-newlru>)
  - [func (c *LRUCache[K, V]) Add(key K, value V) (oldestKey K, oldestValue V, removed bool)](<#func-lrucachek-v-add>)
  - [func (c *LRUCache[K, V]) Count() int](<#func-lrucachek-v-count>)
  - [func (c *LRUCache[K, V]) Flush()](<#func-lrucachek-v-flush>)
  - [func (c *LRUCache[K, V]) Get(key K) (value V, available bool)](<#func-lrucachek-v-get>)
  - [func (c *LRUCache[K, V]) GetOldest() (key K, value V, available bool)](<#func-lrucachek-v-getoldest>)
  - [func (c *LRUCache[K, V]) GetYoungest() (key K, value V, available bool)](<#func-lrucachek-v-getyoungest>)
  - [func (c *LRUCache[K, V]) Remove(key K) (value V, removed bool)](<#func-lrucachek-v-remove>)
  - [func (c *LRUCache[K, V]) RemoveOldest() (key K, value V, removed bool)](<#func-lrucachek-v-removeoldest>)
  - [func (c *LRUCache[K, V]) RemoveYoungest() (key K, value V, removed bool)](<#func-lrucachek-v-removeyoungest>)


## Constants

```go
const (
    NoExpiration      time.Duration = -1
    DefaultExpiration time.Duration = 0
)
```

## type [Cache](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L38-L40>)

Cache is a publicly available struct type, which incorporates the unexported cache struct type holding the cache components.

```go
type Cache[T ~string, V any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

```go
{
	c := New[string, string](DefaultExpiration, 1*time.Minute)
	item, err := c.Get("foo")
	fmt.Println(err)
	fmt.Println(item)

	c.Set("foo", "bar", DefaultExpiration)
	item, _ = c.Get("foo")
	fmt.Println(item.Val())

	err = c.Set("foo", "", DefaultExpiration)
	fmt.Println(err)
	fmt.Println(c.IsExpired("foo"))

	c.Update("foo", "baz", DefaultExpiration)
	item, _ = c.Get("foo")
	fmt.Println(item.Val())

	list := c.List()
	fmt.Println(len(list))

	c.Flush()
	fmt.Println(c.Count())

	c.Set("foo", "bar", DefaultExpiration)
	item, _ = c.Get("foo")
	fmt.Println(item.Val())

	err = c.Delete("foo")
	fmt.Println(err)
	fmt.Println(c.Count())

}
```

#### Output

```
item with key 'foo' not found
<nil>
bar
item with key 'foo' already exists. Use the Update method
false
baz
1
0
bar
<nil>
0
```

</p>
</details>

### func [New](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L58>)

```go
func New[T ~string, V any](expTime, cleanupTime time.Duration) *Cache[T, V]
```

New instantiates a cache struct which requires an expiration time and a cleanup interval. The cache will be invalidated once the expiration time is reached. If the expiration time is less than zero \(or NoExpiration\) the cache items will never expire and should be deleted manually. A cleanup method is running in the background and removes the expired caches at a predefined interval.

### func \(\*Cache\[T, V\]\) [Count](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L222>)

```go
func (c *Cache[T, V]) Count() int
```

Count returns the number of existing items in the cache.

### func \(\*Cache\[T, V\]\) [Delete](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L166>)

```go
func (c *Cache[T, V]) Delete(key T) error
```

Delete removes a cache item.

### func \(\*Cache\[T, V\]\) [Flush](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L207>)

```go
func (c *Cache[T, V]) Flush()
```

Flush removes all the existing items in the cache.

### func \(\*Cache\[T, V\]\) [Get](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L130>)

```go
func (c *Cache[T, V]) Get(key T) (*Item[V], error)
```

Get returns a cache item defined by its key. If the item is expired an error is returned. If an item is expired it's considered as nonexistent, it will be evicted from the cache when the purge method is invoked at the predefined interval.

### func \(\*Cache\[T, V\]\) [IsExpired](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L243>)

```go
func (c *Cache[T, V]) IsExpired(key T) bool
```

IsExpired checks if a cache item is expired.

### func \(\*Cache\[T, V\]\) [List](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L214>)

```go
func (c *Cache[T, V]) List() map[T]*Item[V]
```

List returns the cache items which are not expired.

### func \(\*Cache\[T, V\]\) [MapToCache](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L231>)

```go
func (c *Cache[T, V]) MapToCache(m map[T]V, d time.Duration) error
```

MapToCache transfers the map values into the cache.

### func \(\*Cache\[T, V\]\) [Set](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L75>)

```go
func (c *Cache[T, V]) Set(key T, val V, d time.Duration) error
```

Set inserts a new item into the cache, but first verifies if an item with the same key already exists in the cache. In case an item with the specified key already exists in the cache it will return an error.

### func \(\*Cache\[T, V\]\) [SetDefault](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L86>)

```go
func (c *Cache[T, V]) SetDefault(key T, val V) error
```

SetDefault adds a new item into the cache with the default expiration time.

### func \(\*Cache\[T, V\]\) [Update](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L157>)

```go
func (c *Cache[T, V]) Update(key T, val V, d time.Duration) error
```

Update replaces a cache item with the new value.

## type [Item](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L23-L26>)

Item holds the cache object \(which could be of any type\) and an expiration time. The expiration time defines the object lifetime.

```go
type Item[V any] struct {
    // contains filtered or unexported fields
}
```

### func \(\*Item\[V\]\) [Val](<https://github.com/esimov/gogu/blob/master/cache/cache.go#L148>)

```go
func (it *Item[V]) Val() V
```

Val returns the effective value of the cache item.

## type [LRUCache](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L106-L110>)

LRUCache implements a fixed size LRU cache using a map and a double linked list

```go
type LRUCache[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

### func [NewLRU](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L113>)

```go
func NewLRU[K comparable, V any](size int) (*LRUCache[K, V], error)
```

NewLRU initializes a new LRU cache

### func \(\*LRUCache\[K, V\]\) [Add](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L128>)

```go
func (c *LRUCache[K, V]) Add(key K, value V) (oldestKey K, oldestValue V, removed bool)
```

Add adds a value to the cache. If the oldest value is evicted, this value and they key for it is returned.

### func \(\*LRUCache\[K, V\]\) [Count](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L148>)

```go
func (c *LRUCache[K, V]) Count() int
```

Count return the number of the current values from the cache. It should be LE then the initial size of the cache

### func \(\*LRUCache\[K, V\]\) [Flush](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L210>)

```go
func (c *LRUCache[K, V]) Flush()
```

Flush clears all values from the cache

### func \(\*LRUCache\[K, V\]\) [Get](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L163>)

```go
func (c *LRUCache[K, V]) Get(key K) (value V, available bool)
```

Get return the element for the key if the element is present in the cache

### func \(\*LRUCache\[K, V\]\) [GetOldest](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L153>)

```go
func (c *LRUCache[K, V]) GetOldest() (key K, value V, available bool)
```

GetOldest returns the oldest key/value pair from the cache if the cache has any values

### func \(\*LRUCache\[K, V\]\) [GetYoungest](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L173>)

```go
func (c *LRUCache[K, V]) GetYoungest() (key K, value V, available bool)
```

GetYoungest returns the youngest key/value pair from the cache if the cache has any values

### func \(\*LRUCache\[K, V\]\) [Remove](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L190>)

```go
func (c *LRUCache[K, V]) Remove(key K) (value V, removed bool)
```

Remove removes an element form the cache denoted by the key. The value removed is returned

### func \(\*LRUCache\[K, V\]\) [RemoveOldest](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L181>)

```go
func (c *LRUCache[K, V]) RemoveOldest() (key K, value V, removed bool)
```

RemoveOldest removes the oldest value from the cache. It returns he key/value pair which was removed

### func \(\*LRUCache\[K, V\]\) [RemoveYoungest](<https://github.com/esimov/gogu/blob/master/cache/lrucache.go#L201>)

```go
func (c *LRUCache[K, V]) RemoveYoungest() (key K, value V, removed bool)
```

RemoveYoungest removes the youngest value from the cache. The key/value pair removed is returned



