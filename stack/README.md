<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# stack

```go
import "github.com/esimov/torx/stack"
```

Linked\-list implementation of the LIFO stack.

Package stack implements a concurrent safe LIFO \(Last\-In\-First\-Out\) data structure using as storage a resizing array, where the last element added to the stack is processed first.

<details><summary>Example</summary>
<p>

```go
{
	l := New[string]()

	l.Push("foo")
	fmt.Println(l.Size())
	fmt.Println(l.Peek())
	l.Push("bar")

	fmt.Println(l.Pop())
	fmt.Println(l.Search("foo"))
	fmt.Println(l.Peek())

}
```

#### Output

```
1
foo
bar
true
foo
```

</p>
</details>

<details><summary>Example (,inked List)</summary>
<p>

```go
{
	l := NewLinked("foo")
	fmt.Println(l.Size())
	fmt.Println(l.Peek())

	l.Push("bar")
	fmt.Println(l.Peek())

	fmt.Println(l.Pop())
	fmt.Println(l.Peek())
	fmt.Println(l.Search("foo"))

}
```

#### Output

```
1
foo
bar
foo
foo
true
```

</p>
</details>

## Index

- [type LStack](<#type-lstack>)
  - [func NewLinked[T comparable](t T) *LStack[T]](<#func-newlinked>)
  - [func (s *LStack[T]) Peek() T](<#func-lstackt-peek>)
  - [func (s *LStack[T]) Pop() (item T)](<#func-lstackt-pop>)
  - [func (s *LStack[T]) Push(item T)](<#func-lstackt-push>)
  - [func (s *LStack[T]) Search(item T) bool](<#func-lstackt-search>)
  - [func (s *LStack[T]) Size() int](<#func-lstackt-size>)
- [type Stack](<#type-stack>)
  - [func New[T comparable]() *Stack[T]](<#func-new>)
  - [func (s *Stack[T]) Peek() (item T)](<#func-stackt-peek>)
  - [func (s *Stack[T]) Pop() (item T)](<#func-stackt-pop>)
  - [func (s *Stack[T]) Push(item T)](<#func-stackt-push>)
  - [func (s *Stack[T]) Search(item T) bool](<#func-stackt-search>)
  - [func (s *Stack[T]) Size() int](<#func-stackt-size>)


## type LStack

LStack implements the linked\-list version of the LIFO stack.

```go
type LStack[T comparable] struct {
    list *list.DList[T]
    mu   *sync.RWMutex
    n    int
}
```

### func NewLinked

```go
func NewLinked[T comparable](t T) *LStack[T]
```

NewLinked creates a new LIFO stack where the items are stored in a linked\-list.

### func \(\*LStack\[T\]\) Peek

```go
func (s *LStack[T]) Peek() T
```

Peek returns the last element of the stack. It does not remove it.

### func \(\*LStack\[T\]\) Pop

```go
func (s *LStack[T]) Pop() (item T)
```

Pop retrieves and removes the last element pushed into the stack. The stack size will be decreased by one.

### func \(\*LStack\[T\]\) Push

```go
func (s *LStack[T]) Push(item T)
```

Push inserts a new element at the end of the stack.

### func \(\*LStack\[T\]\) Search

```go
func (s *LStack[T]) Search(item T) bool
```

Search searches for an element in the stack.

### func \(\*LStack\[T\]\) Size

```go
func (s *LStack[T]) Size() int
```

Size returns the stack size.

## type Stack

Stack implements the LIFO Stack.

```go
type Stack[T comparable] struct {
    mu    *sync.RWMutex
    items []T
}
```

### func New

```go
func New[T comparable]() *Stack[T]
```

New creates a new LIFO stack where the items are stored in a plain slice.

### func \(\*Stack\[T\]\) Peek

```go
func (s *Stack[T]) Peek() (item T)
```

Peek returns the last element of the stack without removing it.

### func \(\*Stack\[T\]\) Pop

```go
func (s *Stack[T]) Pop() (item T)
```

Pop retrieves and removes the last element pushed into the stack. The stack size will be decreased by one.

### func \(\*Stack\[T\]\) Push

```go
func (s *Stack[T]) Push(item T)
```

Push inserts a new element at the end of the stack.

### func \(\*Stack\[T\]\) Search

```go
func (s *Stack[T]) Search(item T) bool
```

Search searches for an element in the stack.

### func \(\*Stack\[T\]\) Size

```go
func (s *Stack[T]) Size() int
```

Size returns the LIFO stack size.



