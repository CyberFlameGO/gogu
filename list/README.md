<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# list

```go
import "github.com/esimov/torx/list"
```

Package list provides an implementation of the linked list data structure. It comes with two version: singly and doubly linked list. The singly linked list version has a data element storing the node value and a pointer to the next element of the list. The doubly linked list version has an additional pointer to previous node.

<details><summary>Example (Doubly Linked List)</summary>
<p>

```go
{
	list := InitDList(1)

	values := []int{2, 3, 4, 5, 6, 7, 8}
	for _, val := range values {
		list.Append(val)
	}
	sl := []int{}
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	item := list.Pop()
	fmt.Println(item.data)

	sl = nil
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	item = list.Shift()
	fmt.Println(item.data)

	sl = nil
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	item, err := list.Replace(20, 10)
	fmt.Println(err)
	fmt.Println(item)

	item, err = list.Replace(7, 8)
	fmt.Println(item.data)
	item, err = list.Replace(8, 7)

	n := list.Unshift(1)
	fmt.Println(n.data)

	last := list.Append(8)
	item, _ = list.Find(8)
	fmt.Println(item.data)

	list.InsertAfter(last, 9)

	sl = nil
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	list.Delete(last)

	sl = nil
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	fmt.Println(list.First())
	fmt.Println(list.Last())

}
```

#### Output

```
[1 2 3 4 5 6 7 8]
7
[1 2 3 4 5 6 7]
1
[2 3 4 5 6 7]
requested node does not exists
<nil>
8
1
8
[1 2 3 4 5 6 7 8 9]
[1 2 3 4 5 6 7 9]
1
9
```

</p>
</details>

<details><summary>Example (Singly Linked List)</summary>
<p>

```go
{
	list := Init(1)

	values := []int{2, 3, 4, 5, 6, 7, 8}
	for _, val := range values {
		list.Append(val)
	}
	sl := []int{}
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	item := list.Pop()
	fmt.Println(item.data)

	sl = nil
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	item = list.Shift()
	fmt.Println(item.data)

	sl = nil
	list.Each(func(val int) {
		sl = append(sl, val)
	})
	fmt.Println(sl)

	item, err := list.Replace(20, 10)
	fmt.Println(err)
	fmt.Println(item)

	item, err = list.Replace(7, 8)
	fmt.Println(item.data)

	item, _ = list.Find(8)
	fmt.Println(item.data)

}
```

#### Output

```
[1 2 3 4 5 6 7 8]
7
[1 2 3 4 5 6 7]
1
[2 3 4 5 6 7]
requested node does not exists
<nil>
8
8
```

</p>
</details>

## Index

- [type DList](<#type-dlist>)
  - [func InitDList[T comparable](data T) *DList[T]](<#func-initdlist>)
  - [func (l *DList[T]) Append(data T) *doubleNode[T]](<#func-dlistt-append>)
  - [func (l *DList[T]) Clear()](<#func-dlistt-clear>)
  - [func (l *DList[T]) Data(node *doubleNode[T]) T](<#func-dlistt-data>)
  - [func (l *DList[T]) Delete(node *doubleNode[T]) error](<#func-dlistt-delete>)
  - [func (l *DList[T]) Each(fn func(data T))](<#func-dlistt-each>)
  - [func (l *DList[T]) Find(val T) (*doubleNode[T], bool)](<#func-dlistt-find>)
  - [func (l *DList[T]) First() T](<#func-dlistt-first>)
  - [func (l *DList[T]) InsertAfter(prev *doubleNode[T], data T) error](<#func-dlistt-insertafter>)
  - [func (l *DList[T]) InsertBefore(node *doubleNode[T], data T) error](<#func-dlistt-insertbefore>)
  - [func (l *DList[T]) Last() T](<#func-dlistt-last>)
  - [func (l *DList[T]) Pop() *doubleNode[T]](<#func-dlistt-pop>)
  - [func (l *DList[T]) Replace(oldVal, newVal T) (*doubleNode[T], error)](<#func-dlistt-replace>)
  - [func (l *DList[T]) Shift() *doubleNode[T]](<#func-dlistt-shift>)
  - [func (l *DList[T]) Unshift(data T) *doubleNode[T]](<#func-dlistt-unshift>)
- [type SList](<#type-slist>)
  - [func Init[T comparable](data T) *SList[T]](<#func-init>)
  - [func (l *SList[T]) Append(data T) *singleNode[T]](<#func-slistt-append>)
  - [func (l *SList[T]) Delete(node *singleNode[T]) error](<#func-slistt-delete>)
  - [func (l *SList[T]) Each(fn func(data T))](<#func-slistt-each>)
  - [func (l *SList[T]) Find(val T) (*singleNode[T], bool)](<#func-slistt-find>)
  - [func (l *SList[T]) InsertAfter(prev *singleNode[T], data T) error](<#func-slistt-insertafter>)
  - [func (l *SList[T]) Pop() *singleNode[T]](<#func-slistt-pop>)
  - [func (l *SList[T]) Replace(oldVal, newVal T) (*singleNode[T], error)](<#func-slistt-replace>)
  - [func (l *SList[T]) Shift() *singleNode[T]](<#func-slistt-shift>)
  - [func (l *SList[T]) Unshift(data T)](<#func-slistt-unshift>)


## type DList

DList contains the node elements of the doubly linked list.

```go
type DList[T comparable] struct {
    // contains filtered or unexported fields
}
```

### func InitDList

```go
func InitDList[T comparable](data T) *DList[T]
```

InitDList initializes a doubly linked list with one node. Because this is the only node in the list, its next and prev pointers are nil.

### func \(\*DList\[T\]\) Append

```go
func (l *DList[T]) Append(data T) *doubleNode[T]
```

Append inserts a new node at the end of the doubly linked list.

### func \(\*DList\[T\]\) Clear

```go
func (l *DList[T]) Clear()
```

Clear deletes all the nodes from the list.

### func \(\*DList\[T\]\) Data

```go
func (l *DList[T]) Data(node *doubleNode[T]) T
```

Data retrieves the node value.

### func \(\*DList\[T\]\) Delete

```go
func (l *DList[T]) Delete(node *doubleNode[T]) error
```

Delete removes the specified node from the list.

### func \(\*DList\[T\]\) Each

```go
func (l *DList[T]) Each(fn func(data T))
```

Each iterates over the elements of the linked list and invokes the callback function having as parameter the nodes data.

### func \(\*DList\[T\]\) Find

```go
func (l *DList[T]) Find(val T) (*doubleNode[T], bool)
```

Find search for a node element in the linked list. It returns the node in case the element is found otherwise nil.

### func \(\*DList\[T\]\) First

```go
func (l *DList[T]) First() T
```

First retrieves the first element of the doubly linked list.

### func \(\*DList\[T\]\) InsertAfter

```go
func (l *DList[T]) InsertAfter(prev *doubleNode[T], data T) error
```

InsertAfter inserts a new node after the existing node. In case the requested node is not in the list it returns an error.

### func \(\*DList\[T\]\) InsertBefore

```go
func (l *DList[T]) InsertBefore(node *doubleNode[T], data T) error
```

InsertBefore inserts a new node before the current node. In case the requested node is not in the list it returns an error.

### func \(\*DList\[T\]\) Last

```go
func (l *DList[T]) Last() T
```

Last retrieves the last element of the doubly linked list.

### func \(\*DList\[T\]\) Pop

```go
func (l *DList[T]) Pop() *doubleNode[T]
```

Pop removes the last node from the list.

### func \(\*DList\[T\]\) Replace

```go
func (l *DList[T]) Replace(oldVal, newVal T) (*doubleNode[T], error)
```

Replace replaces a node's value with the new one. It returns an error in case the requested node does not exists.

### func \(\*DList\[T\]\) Shift

```go
func (l *DList[T]) Shift() *doubleNode[T]
```

Shift removes the first node from the list.

### func \(\*DList\[T\]\) Unshift

```go
func (l *DList[T]) Unshift(data T) *doubleNode[T]
```

Unshift inserts a new node at the beginning of the doubly linked list.

## type SList

SList is a struct containing the individual nodes of the list.

```go
type SList[T comparable] struct {
    // contains filtered or unexported fields
}
```

### func Init

```go
func Init[T comparable](data T) *SList[T]
```

Init initializes a new singly linked list with one node. Because this is the only node in the list its next pointer will be nil.

### func \(\*SList\[T\]\) Append

```go
func (l *SList[T]) Append(data T) *singleNode[T]
```

Append inserts a new node at the end of the list.

### func \(\*SList\[T\]\) Delete

```go
func (l *SList[T]) Delete(node *singleNode[T]) error
```

Delete removes the specified node from the list.

### func \(\*SList\[T\]\) Each

```go
func (l *SList[T]) Each(fn func(data T))
```

Each iterates over the elements of the linked list and invokes the callback function, having as parameter the nodes data.

### func \(\*SList\[T\]\) Find

```go
func (l *SList[T]) Find(val T) (*singleNode[T], bool)
```

Find search for a node element in the linked list. It returns the node in case the element is found otherwise nil.

### func \(\*SList\[T\]\) InsertAfter

```go
func (l *SList[T]) InsertAfter(prev *singleNode[T], data T) error
```

InsertAfter inserts a new node after the current node. In case the requested node is not in the list it returns an error.

### func \(\*SList\[T\]\) Pop

```go
func (l *SList[T]) Pop() *singleNode[T]
```

Pop removes the last node from the list.

### func \(\*SList\[T\]\) Replace

```go
func (l *SList[T]) Replace(oldVal, newVal T) (*singleNode[T], error)
```

Replace replaces a node's value with a new one. It returns an error in case the requested node does not exists.

### func \(\*SList\[T\]\) Shift

```go
func (l *SList[T]) Shift() *singleNode[T]
```

Shift removes the first node from the list.

### func \(\*SList\[T\]\) Unshift

```go
func (l *SList[T]) Unshift(data T)
```

Unshift inserts a new node at the beginning of the list.



