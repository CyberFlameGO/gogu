<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# torx

```go
import "github.com/esimov/torx"
```

## Index

- [Variables](<#variables>)
- [func Abs[T Number](x T) T](<#func-abs>)
- [func After[V constraints.Signed](n *V, fn func())](<#func-after>)
- [func Before[S ~string, T any, V constraints.Signed](n *V, c *cache.Cache[S, T], fn func() T) T](<#func-before>)
- [func CamelCase[T ~string](str T) T](<#func-camelcase>)
- [func Capitalize[T ~string](str T) T](<#func-capitalize>)
- [func Chunk[T comparable](slice []T, size int) [][]T](<#func-chunk>)
- [func Clamp[T Number](num, lo, up T) T](<#func-clamp>)
- [func Compare[T comparable](a, b T, comp CompFn[T]) int](<#func-compare>)
- [func Contains[T comparable](slice []T, value T) bool](<#func-contains>)
- [func Delay(delay time.Duration, fn func()) *time.Timer](<#func-delay>)
- [func Difference[T comparable](s1, s2 []T) []T](<#func-difference>)
- [func DifferenceBy[T comparable](s1, s2 []T, fn func(T) T) []T](<#func-differenceby>)
- [func Drop[T any](slice []T, n int) []T](<#func-drop>)
- [func DropRightWhile[T any](slice []T, fn func(T) bool) []T](<#func-droprightwhile>)
- [func DropWhile[T any](slice []T, fn func(T) bool) []T](<#func-dropwhile>)
- [func Duplicate[T comparable](slice []T) []T](<#func-duplicate>)
- [func DuplicateWithIndex[T comparable](slice []T) map[T]int](<#func-duplicatewithindex>)
- [func Equal[T comparable](a, b T) bool](<#func-equal>)
- [func Every[T any](slice []T, fn func(T) bool) bool](<#func-every>)
- [func Filter[T any](slice []T, fn func(T) bool) []T](<#func-filter>)
- [func Filter2DMapCollection[K comparable, V any](collection []map[K]map[K]V, fn func(map[K]V) bool) []map[K]map[K]V](<#func-filter2dmapcollection>)
- [func FilterMap[K comparable, V any](m map[K]V, fn func(V) bool) map[K]V](<#func-filtermap>)
- [func FilterMapCollection[K comparable, V any](collection []map[K]V, fn func(V) bool) []map[K]V](<#func-filtermapcollection>)
- [func Find[K constraints.Ordered, V any](m map[K]V, fn func(V) bool) map[K]V](<#func-find>)
- [func FindAll[T any](s []T, fn func(T) bool) map[int]T](<#func-findall>)
- [func FindByKey[K comparable, V any](m map[K]V, fn func(K) bool) map[K]V](<#func-findbykey>)
- [func FindIndex[T any](s []T, fn func(T) bool) int](<#func-findindex>)
- [func FindKey[K comparable, V any](m map[K]V, fn func(V) bool) K](<#func-findkey>)
- [func FindLastIndex[T any](s []T, fn func(T) bool) int](<#func-findlastindex>)
- [func FindMax[T constraints.Ordered](s []T) T](<#func-findmax>)
- [func FindMaxBy[T constraints.Ordered](s []T, fn func(val T) T) T](<#func-findmaxby>)
- [func FindMaxByKey[K comparable, T constraints.Ordered](mapSlice []map[K]T, key K) (T, error)](<#func-findmaxbykey>)
- [func FindMin[T constraints.Ordered](s []T) T](<#func-findmin>)
- [func FindMinBy[T constraints.Ordered](s []T, fn func(val T) T) T](<#func-findminby>)
- [func FindMinByKey[K comparable, T constraints.Ordered](mapSlice []map[K]T, key K) (T, error)](<#func-findminbykey>)
- [func Flatten[T any](slice any) ([]T, error)](<#func-flatten>)
- [func Flip[T any](fn func(args ...T) []T) func(args ...T) []T](<#func-flip>)
- [func ForEach[T any](slice []T, fn func(T))](<#func-foreach>)
- [func ForEachRight[T any](slice []T, fn func(T))](<#func-foreachright>)
- [func GroupBy[T1, T2 comparable](slice []T1, fn func(T1) T2) map[T2][]T1](<#func-groupby>)
- [func InRange[T Number](num, lo, up T) bool](<#func-inrange>)
- [func IndexOf[T comparable](s []T, val T) int](<#func-indexof>)
- [func Intersection[T comparable](params ...[]T) []T](<#func-intersection>)
- [func IntersectionBy[T comparable](fn func(T) T, params ...[]T) []T](<#func-intersectionby>)
- [func Invert[K, V comparable](m map[K]V) map[V]K](<#func-invert>)
- [func KebabCase[T ~string](str T) T](<#func-kebabcase>)
- [func Keys[K comparable, V any](m map[K]V) []K](<#func-keys>)
- [func LastIndexOf[T comparable](s []T, val T) int](<#func-lastindexof>)
- [func Less[T constraints.Ordered](a, b T) bool](<#func-less>)
- [func Map[T1, T2 any](slice []T1, fn func(T1) T2) []T2](<#func-map>)
- [func MapCollection[K comparable, V any](m map[K]V, fn func(V) V) []V](<#func-mapcollection>)
- [func MapContains[K, V comparable](m map[K]V, value V) bool](<#func-mapcontains>)
- [func MapEvery[K comparable, V any](m map[K]V, fn func(V) bool) bool](<#func-mapevery>)
- [func MapKeys[K comparable, V any, R comparable](m map[K]V, fn func(K, V) R) map[R]V](<#func-mapkeys>)
- [func MapSome[K comparable, V any](m map[K]V, fn func(V) bool) bool](<#func-mapsome>)
- [func MapUnique[K, V comparable](m map[K]V) map[K]V](<#func-mapunique>)
- [func MapValues[K comparable, V, R any](m map[K]V, fn func(V) R) map[K]R](<#func-mapvalues>)
- [func Max[T constraints.Ordered](values ...T) T](<#func-max>)
- [func Mean[T Number](slice []T) T](<#func-mean>)
- [func Merge[T any](s []T, params ...[]T) []T](<#func-merge>)
- [func Min[T constraints.Ordered](values ...T) T](<#func-min>)
- [func N[T Number](s string) (T, error)](<#func-n>)
- [func NewDebounce(wait time.Duration) (func(f func()), func())](<#func-newdebounce>)
- [func Nth[T any](slice []T, nth int) (T, error)](<#func-nth>)
- [func Null[T any]() T](<#func-null>)
- [func NumToString[T Number](n T) string](<#func-numtostring>)
- [func Omit[K comparable, V any](collection map[K]V, keys ...K) map[K]V](<#func-omit>)
- [func OmitBy[K comparable, V any](collection map[K]V, fn func(key K, val V) bool) map[K]V](<#func-omitby>)
- [func Once[S ~string, T any](c *cache.Cache[S, T], fn func() T) T](<#func-once>)
- [func Pad[T ~string](str T, size int, token string) T](<#func-pad>)
- [func PadLeft[T ~string](str T, size int, token string) T](<#func-padleft>)
- [func PadRight[T ~string](str T, size int, token string) T](<#func-padright>)
- [func Partition[T comparable](slice []T, fn func(T) bool) [2][]T](<#func-partition>)
- [func PartitionMap[K comparable, V any](mapSlice []map[K]V, fn func(map[K]V) bool) [2][]map[K]V](<#func-partitionmap>)
- [func Pick[K comparable, V any](collection map[K]V, keys ...K) (map[K]V, error)](<#func-pick>)
- [func PickBy[K comparable, V any](collection map[K]V, fn func(key K, val V) bool) map[K]V](<#func-pickby>)
- [func Pluck[K comparable, V any](mapSlice []map[K]V, key K) []V](<#func-pluck>)
- [func Range[T Number](args ...T) ([]T, error)](<#func-range>)
- [func RangeRight[T Number](params ...T) ([]T, error)](<#func-rangeright>)
- [func Reduce[T1, T2 any](slice []T1, fn func(T1, T2) T2, initVal T2) T2](<#func-reduce>)
- [func Reject[T any](slice []T, fn func(val T) bool) []T](<#func-reject>)
- [func Reverse[T any](sl []T) []T](<#func-reverse>)
- [func ReverseStr[T ~string](str T) T](<#func-reversestr>)
- [func Shuffle[T any](src []T) []T](<#func-shuffle>)
- [func SliceToMap[K comparable, T any](s1 []K, s2 []T) map[K]T](<#func-slicetomap>)
- [func SnakeCase[T ~string](str T) T](<#func-snakecase>)
- [func Some[T any](slice []T, fn func(T) bool) bool](<#func-some>)
- [func SplitAtIndex[T ~string](str T, index int) []T](<#func-splitatindex>)
- [func Substr[T ~string](str T, offset, length int) T](<#func-substr>)
- [func Sum[T Number](slice []T) T](<#func-sum>)
- [func SumBy[T1 any, T2 Number](slice []T1, fn func(T1) T2) T2](<#func-sumby>)
- [func ToLower[T ~string](str T) T](<#func-tolower>)
- [func ToSlice[T any](args ...T) []T](<#func-toslice>)
- [func ToUpper[T ~string](str T) T](<#func-toupper>)
- [func Union[T comparable](slice any) ([]T, error)](<#func-union>)
- [func Unique[T comparable](slice []T) []T](<#func-unique>)
- [func UniqueBy[T comparable](slice []T, fn func(T) T) []T](<#func-uniqueby>)
- [func Unwrap[T ~string](str T, token string) T](<#func-unwrap>)
- [func Unzip[T any](slices ...[]T) [][]T](<#func-unzip>)
- [func Values[K comparable, V any](m map[K]V) []V](<#func-values>)
- [func Without[T1 comparable, T2 any](slice []T1, values ...T1) []T1](<#func-without>)
- [func Wrap[T ~string](str T, token string) T](<#func-wrap>)
- [func WrapAllRune[T ~string](str T, token string) T](<#func-wrapallrune>)
- [func Zip[T any](slices ...[]T) [][]T](<#func-zip>)
- [func baseFlatten[T any](acc []T, slice any) ([]T, error)](<#func-baseflatten>)
- [func mapByIndex[T1 comparable, T2 any](origSlice []T2, mapSlice []T1) map[T1][]T2](<#func-mapbyindex>)
- [func splitStringWithDelimiter[T ~string](str T, delimiter string) T](<#func-splitstringwithdelimiter>)
- [func swap[T any](a, b *T)](<#func-swap>)
- [type Bound](<#type-bound>)
  - [func (b Bound[T]) Enclose(nth T) bool](<#func-boundt-enclose>)
- [type CompFn](<#type-compfn>)
- [type Memoizer](<#type-memoizer>)
  - [func NewMemoizer[T ~string, V any](expiration, cleanup time.Duration) *Memoizer[T, V]](<#func-newmemoizer>)
  - [func (m Memoizer[T, V]) Memoize(key T, fn func() (*cache.Item[V], error)) (*cache.Item[V], error)](<#func-memoizert-v-memoize>)
- [type Number](<#type-number>)
- [type RType](<#type-rtype>)
  - [func (v RType[T]) Retry(n int, fn func(T) error) (int, error)](<#func-rtypet-retry>)
  - [func (v RType[T]) RetryWithDelay(n int, delay time.Duration, fn func(time.Duration, T) error) (time.Duration, int, error)](<#func-rtypet-retrywithdelay>)
- [type debouncer](<#type-debouncer>)
  - [func (d *debouncer) add(f func())](<#func-debouncer-add>)
  - [func (d *debouncer) cancel()](<#func-debouncer-cancel>)
- [type throttler](<#type-throttler>)
  - [func NewThrottle(wait time.Duration, trailing bool) *throttler](<#func-newthrottle>)
  - [func (t *throttler) Call()](<#func-throttler-call>)
  - [func (t *throttler) Cancel()](<#func-throttler-cancel>)
  - [func (t *throttler) Next() bool](<#func-throttler-next>)


## Variables

```go
var n = 2
```

## func Abs

```go
func Abs[T Number](x T) T
```

Abs returns the absolut value of x.

## func After

```go
func After[V constraints.Signed](n *V, fn func())
```

After creates a function wrapper that does nothing at first. From the nth call onwards, it starts actually calling the callback function. Useful for grouping responses, where you want to be sure that all the calls have finished, before proceeding.

## func Before

```go
func Before[S ~string, T any, V constraints.Signed](n *V, c *cache.Cache[S, T], fn func() T) T
```

Before creates a function wrapper that memoizes its return value. From the nth call onwards, the memoized result of the last invocation is returned immediately instead of invoking function again. So the wrapper will invoke function at most n\-1 times.

## func CamelCase

```go
func CamelCase[T ~string](str T) T
```

CamelCase converts a string to camelCase \(https://en.wikipedia.org/wiki/CamelCase\).

## func Capitalize

```go
func Capitalize[T ~string](str T) T
```

Capitalize converts the first letter of the string to uppercase and the remaining letters to lowercase.

## func Chunk

```go
func Chunk[T comparable](slice []T, size int) [][]T
```

Chunk split the slice into groups of slices each having the length of size. In case the source slice cannot be distributed equally, the last slice will contain fewer elements.

## func Clamp

```go
func Clamp[T Number](num, lo, up T) T
```

Clamp restricts a number between two other numbers.

## func Compare

```go
func Compare[T comparable](a, b T, comp CompFn[T]) int
```

Compare compares two values using as comparator the the callback function argument.

## func Contains

```go
func Contains[T comparable](slice []T, value T) bool
```

Contains returns true if the value is present in the collection.

## func Delay

```go
func Delay(delay time.Duration, fn func()) *time.Timer
```

Delay invokes the function with a predefined delay.

## func Difference

```go
func Difference[T comparable](s1, s2 []T) []T
```

Difference is similar to Without, but returns the values from the first slice that are not present in the second slice.

## func DifferenceBy

```go
func DifferenceBy[T comparable](s1, s2 []T, fn func(T) T) []T
```

DifferenceBy is like Difference, except that invokes a callback function on each element of the slice, applying the criteria by which the difference is computed.

## func Drop

```go
func Drop[T any](slice []T, n int) []T
```

Drop creates a new slice with n elements dropped from the beginning. If n \< 0 the elements will be dropped from the back of the collection.

## func DropRightWhile

```go
func DropRightWhile[T any](slice []T, fn func(T) bool) []T
```

DropRightWhile creates a new slice excluding the elements dropped from the end. Elements are dropped by applying the conditional invoked in the callback function.

## func DropWhile

```go
func DropWhile[T any](slice []T, fn func(T) bool) []T
```

DropWhile creates a new slice excluding the elements dropped from the beginning. Elements are dropped by applying the conditional invoked in the callback function.

## func Duplicate

```go
func Duplicate[T comparable](slice []T) []T
```

Duplicate returns the duplicated values of a collection.

## func DuplicateWithIndex

```go
func DuplicateWithIndex[T comparable](slice []T) map[T]int
```

DuplicateWithIndex puts the duplicated values of a collection into a map as a key value pair, where the key is the collection element and the value is it's position.

## func Equal

```go
func Equal[T comparable](a, b T) bool
```

Equal checks if two values are equal.

## func Every

```go
func Every[T any](slice []T, fn func(T) bool) bool
```

Every returns true if all of the elements of a slice satisfies the criteria of the callback function.

## func Filter

```go
func Filter[T any](slice []T, fn func(T) bool) []T
```

Filter returns all the elements from the collection which satisfies the conditional logic of the callback function.

## func Filter2DMapCollection

```go
func Filter2DMapCollection[K comparable, V any](collection []map[K]map[K]V, fn func(map[K]V) bool) []map[K]map[K]V
```

Filter2DMapCollection filter out a two dimmensional collection of map items by applying the conditional logic of the callback function.

## func FilterMap

```go
func FilterMap[K comparable, V any](m map[K]V, fn func(V) bool) map[K]V
```

FilterMap iterates over the elements of a collection and returns a new collection representing all the items which satisfies the criteria formulated in the callback function.

## func FilterMapCollection

```go
func FilterMapCollection[K comparable, V any](collection []map[K]V, fn func(V) bool) []map[K]V
```

FilterMapCollection filter out a one dimmensional collection of map items by applying the conditional logic of the callback function.

## func Find

```go
func Find[K constraints.Ordered, V any](m map[K]V, fn func(V) bool) map[K]V
```

Find iterates over the elements of a map and returns the first item for which the callback function returns true.

## func FindAll

```go
func FindAll[T any](s []T, fn func(T) bool) map[int]T
```

FindAll is like FindIndex, but inserts into a map all the values which stisfies the conditional logic of the callback function. The map key represents the position of the found value and the value is the item itself.

## func FindByKey

```go
func FindByKey[K comparable, V any](m map[K]V, fn func(K) bool) map[K]V
```

FindByKey is like Find, but returns the first item for which the callback function returns true.

## func FindIndex

```go
func FindIndex[T any](s []T, fn func(T) bool) int
```

FindIndex returns the index of the first found element.

## func FindKey

```go
func FindKey[K comparable, V any](m map[K]V, fn func(V) bool) K
```

FindKey is like Find, but returns the first item key position for which the callback function returns true.

## func FindLastIndex

```go
func FindLastIndex[T any](s []T, fn func(T) bool) int
```

FindLastIndex is like FindIndex, only that returns the index of last found element.

## func FindMax

```go
func FindMax[T constraints.Ordered](s []T) T
```

FindMax finds the maximum value of a slice.

## func FindMaxBy

```go
func FindMaxBy[T constraints.Ordered](s []T, fn func(val T) T) T
```

FindMaxBy is like FindMax except that it accept a callback function and the conditional logic is applied over the resulted value. If there are more than one identical values resulted from the callback function the first one is used.

## func FindMaxByKey

```go
func FindMaxByKey[K comparable, T constraints.Ordered](mapSlice []map[K]T, key K) (T, error)
```

FindMaxByKey finds the maximum value from a map by using some existing key as a parameter.

## func FindMin

```go
func FindMin[T constraints.Ordered](s []T) T
```

FindMin finds the minumum value of a slice.

## func FindMinBy

```go
func FindMinBy[T constraints.Ordered](s []T, fn func(val T) T) T
```

FindMinBy is like FindMin except that it accept a callback function and the conditional logic is applied over the resulted value. If there are more than one identical values resulted from the callback function the first one is used.

## func FindMinByKey

```go
func FindMinByKey[K comparable, T constraints.Ordered](mapSlice []map[K]T, key K) (T, error)
```

FindMinByKey finds the minimum value from a map by using some existing key as a parameter.

## func Flatten

```go
func Flatten[T any](slice any) ([]T, error)
```

Flatten flattens the slice all the way to the deepest nesting level.

## func Flip

```go
func Flip[T any](fn func(args ...T) []T) func(args ...T) []T
```

Flip creates a function that invokes fn with arguments reversed.

## func ForEach

```go
func ForEach[T any](slice []T, fn func(T))
```

ForEach iterates over the elements of a collection and invokes the callback fn function on each element.

## func ForEachRight

```go
func ForEachRight[T any](slice []T, fn func(T))
```

ForEachRight is the same as ForEach, but starts the iteration from the last element.

## func GroupBy

```go
func GroupBy[T1, T2 comparable](slice []T1, fn func(T1) T2) map[T2][]T1
```

GroupBy splits a collection into a key\-value set, grouped by the result of running each value through the callback function fn. The return value is a map where the key is the conditional logic of the callback function and the values are the callback function returned values.

## func InRange

```go
func InRange[T Number](num, lo, up T) bool
```

InRange checks if a number is inside a range.

## func IndexOf

```go
func IndexOf[T comparable](s []T, val T) int
```

IndexOf returns the index at which value can be found in the slice, or \-1 if value is not present in the slice.

## func Intersection

```go
func Intersection[T comparable](params ...[]T) []T
```

Intersection computes the list of values that are the intersection of all the slices. Each value in the result should be present in each of the provided slices.

## func IntersectionBy

```go
func IntersectionBy[T comparable](fn func(T) T, params ...[]T) []T
```

IntersectionBy is like Intersection, except that it accepts and callback function which is invoked on each element of the collection.

## func Invert

```go
func Invert[K, V comparable](m map[K]V) map[V]K
```

Invert returns a copy of the map where the keys become the values and the values the keys. For this to work, all of your map's values should be unique.

## func KebabCase

```go
func KebabCase[T ~string](str T) T
```

KebabCase converts a string to kebab\-case \(https://en.wikipedia.org/wiki/Letter_case#Kebab_case\).

## func Keys

```go
func Keys[K comparable, V any](m map[K]V) []K
```

Keys retrieve all the existing keys of a map.

## func LastIndexOf

```go
func LastIndexOf[T comparable](s []T, val T) int
```

LastIndexOf returns the index of the last occurrence of a value.

## func Less

```go
func Less[T constraints.Ordered](a, b T) bool
```

Less checks if the first value is less than the second.

## func Map

```go
func Map[T1, T2 any](slice []T1, fn func(T1) T2) []T2
```

Map produces a new slice of values by mapping each value in the list through a transformation function.

## func MapCollection

```go
func MapCollection[K comparable, V any](m map[K]V, fn func(V) V) []V
```

MapCollection is like the Map method applied on slices, but this time applied on maps. It runs each element over an iteratee function and saves the resulted values into a new map.

## func MapContains

```go
func MapContains[K, V comparable](m map[K]V, value V) bool
```

MapContains returns true if the value is present in the list otherwise false.

## func MapEvery

```go
func MapEvery[K comparable, V any](m map[K]V, fn func(V) bool) bool
```

MapEvery returns true if all of the elements of a map satisfies the criteria of the callback function.

## func MapKeys

```go
func MapKeys[K comparable, V any, R comparable](m map[K]V, fn func(K, V) R) map[R]V
```

MapKeys is the opposite of MapValues. It creates a new map with the same number of elements as the original one, but this time the callback function \(fn\) is invoked over the map keys.

## func MapSome

```go
func MapSome[K comparable, V any](m map[K]V, fn func(V) bool) bool
```

MapSome returns true if some of the elements of a map satisfies the criteria of the callback function.

## func MapUnique

```go
func MapUnique[K, V comparable](m map[K]V) map[K]V
```

MapUnique removes the duplicate values from a map.

## func MapValues

```go
func MapValues[K comparable, V, R any](m map[K]V, fn func(V) R) map[K]R
```

MapValues creates a new map with the same number of elements as the original one, but running each map value through a callback function \(fn\).

## func Max

```go
func Max[T constraints.Ordered](values ...T) T
```

Max returns the biggest value from the provided parameters.

## func Mean

```go
func Mean[T Number](slice []T) T
```

Mean computes the mean value of the slice elements.

## func Merge

```go
func Merge[T any](s []T, params ...[]T) []T
```

Merge merges the first slice with the other slices defined as variadic parameter.

## func Min

```go
func Min[T constraints.Ordered](values ...T) T
```

Min returns the lowest value from the provided parameters.

## func N

```go
func N[T Number](s string) (T, error)
```

N converts a string to a generic number.

## func NewDebounce

```go
func NewDebounce(wait time.Duration) (func(f func()), func())
```

NewDebounce creates a new debounced version of the invoked function which will postpone the execution until the time duration has elapsed since the last invocation passed in as a function argument.

It returns a callback function which will be invoked after the predefined delay and also a cancel function which should be invoked to cancel a scheduled debounce.

## func Nth

```go
func Nth[T any](slice []T, nth int) (T, error)
```

Nth returns the nth element of the collection. In case of negative value the nth element is returned from the end of the collection. In case nth is out of bounds an error is returned.

## func Null

```go
func Null[T any]() T
```

## func NumToString

```go
func NumToString[T Number](n T) string
```

NumToString converts a number to a string. In case of a number of type float \(float32|float64\) this will be rounded to 2 decimal places.

## func Omit

```go
func Omit[K comparable, V any](collection map[K]V, keys ...K) map[K]V
```

Omit is the opposite of Pick, it extracts all the map elements which keys are not omitted.

## func OmitBy

```go
func OmitBy[K comparable, V any](collection map[K]V, fn func(key K, val V) bool) map[K]V
```

OmitBy is the opposite of Omit, it removes all the map elements for which the callback function returns true.

## func Once

```go
func Once[S ~string, T any](c *cache.Cache[S, T], fn func() T) T
```

Once is like Before, but it's invoked only once. Repeated calls to the modified function will have no effect, returning the value from the cache.

## func Pad

```go
func Pad[T ~string](str T, size int, token string) T
```

Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.

## func PadLeft

```go
func PadLeft[T ~string](str T, size int, token string) T
```

PadLeft pads string on the left side if it's shorter than length. Padding characters are truncated if they exceed length.

## func PadRight

```go
func PadRight[T ~string](str T, size int, token string) T
```

PadRight pads string on the right side if it's shorter than length. Padding characters are truncated if they exceed length.

## func Partition

```go
func Partition[T comparable](slice []T, fn func(T) bool) [2][]T
```

Partition splits the collection elements into two, the ones which satisfies the condition expressed in the callback function \(fn\) and those which does not satisfies the condition.

## func PartitionMap

```go
func PartitionMap[K comparable, V any](mapSlice []map[K]V, fn func(map[K]V) bool) [2][]map[K]V
```

PartitionMap split the collection into two arrays, the one whose elements satisfies the condition expressed in the callback function \(fn\) and one whose elements don't satisfies the condition.

## func Pick

```go
func Pick[K comparable, V any](collection map[K]V, keys ...K) (map[K]V, error)
```

Pick extracts the elements from the map which have the key defined in the allowed keys.

## func PickBy

```go
func PickBy[K comparable, V any](collection map[K]V, fn func(key K, val V) bool) map[K]V
```

PickBy extracts all the map elements for which the callback function returns truthy.

## func Pluck

```go
func Pluck[K comparable, V any](mapSlice []map[K]V, key K) []V
```

Pluck extracts all the values of a map by the key definition.

## func Range

```go
func Range[T Number](args ...T) ([]T, error)
```

Range creates a slice of numbers \(integers\) progressing from start up to, but not including end. This method can accept 1, 2 or 3 arguments. Depending on the number of provided parameters, \`start\`, \`step\` and \`end\` has the following meaning: \[start=0\]: The start of the range. If ommited it defaults to 0. \[step=1\]: The value to increment or decrement by. end: The end of the range. In case you'd like negative values, use a negative step.

## func RangeRight

```go
func RangeRight[T Number](params ...T) ([]T, error)
```

RangeRight is like Range, only that it populates the slice in descending order.

## func Reduce

```go
func Reduce[T1, T2 any](slice []T1, fn func(T1, T2) T2, initVal T2) T2
```

Reduce reduces the collection to a value which is the accumulated result of running each element in the collection through the callback function yielding a single value.

## func Reject

```go
func Reject[T any](slice []T, fn func(val T) bool) []T
```

Reject is the opposite of Filter. It returns the values from the collection without the elements for which the callback function returns true.

## func Reverse

```go
func Reverse[T any](sl []T) []T
```

Reverse reverses the order of elements, so that the first element becomes the last, the second element becomes the second to last, and so on.

## func ReverseStr

```go
func ReverseStr[T ~string](str T) T
```

ReverseStr returns a new string with the characters in reverse order.

## func Shuffle

```go
func Shuffle[T any](src []T) []T
```

Shuffle implements the Fisher\-Yates shuffle algorithm applied to a slice.

## func SliceToMap

```go
func SliceToMap[K comparable, T any](s1 []K, s2 []T) map[K]T
```

SliceToMap converts a slice to a map. It panic in case the parameter slices lenght are not identical. The map keys will be the items from the first slice and the values the items from the second slice.

## func SnakeCase

```go
func SnakeCase[T ~string](str T) T
```

SnakeCase converts a string to snake\_case \(https://en.wikipedia.org/wiki/Snake_case\).

## func Some

```go
func Some[T any](slice []T, fn func(T) bool) bool
```

Some returns true if some of the elements of a slice satisfies the criteria of the callback function.

## func SplitAtIndex

```go
func SplitAtIndex[T ~string](str T, index int) []T
```

SplitAtIndex split the string at the specified index and returns a slice with the resulted two substrings.

## func Substr

```go
func Substr[T ~string](str T, offset, length int) T
```

If length is negative, then that many characters will be omitted from the end of string starting from the offset position.

## func Sum

```go
func Sum[T Number](slice []T) T
```

Sum returns the sum of the slice items. These have to satisfy the type constraints declared as Number.

## func SumBy

```go
func SumBy[T1 any, T2 Number](slice []T1, fn func(T1) T2) T2
```

SumBy is like Sum except the it accept a callback function which is invoked for each element in the slice to generate the value to be summed.

## func ToLower

```go
func ToLower[T ~string](str T) T
```

ToLower converts a string to Lowercase.

## func ToSlice

```go
func ToSlice[T any](args ...T) []T
```

ToSlice returns the function arguments as a slice.

## func ToUpper

```go
func ToUpper[T ~string](str T) T
```

ToUpper converts a string to Uppercase.

## func Union

```go
func Union[T comparable](slice any) ([]T, error)
```

Union computes the union of the passed\-in slice and returns in order the list of unique items that are present in one or more of the slices.

## func Unique

```go
func Unique[T comparable](slice []T) []T
```

Unique returns the collection unique values.

## func UniqueBy

```go
func UniqueBy[T comparable](slice []T, fn func(T) T) []T
```

UniqueBy is like Unique except that it accept a callback function which is invoked on each element of the slice applying the criteria by which the uniqueness is computed.

## func Unwrap

```go
func Unwrap[T ~string](str T, token string) T
```

Unwrap a string with the specified token.

## func Unzip

```go
func Unzip[T any](slices ...[]T) [][]T
```

Zip iteratively merges together the values of the slice parameters with the values at the corresponding position.

## func Values

```go
func Values[K comparable, V any](m map[K]V) []V
```

Values retrieve all the existing values of a map.

## func Without

```go
func Without[T1 comparable, T2 any](slice []T1, values ...T1) []T1
```

Without returns a copy of the slice with all the values defined in the variadic parameter removed.

## func Wrap

```go
func Wrap[T ~string](str T, token string) T
```

Wrap a string with the specified token.

## func WrapAllRune

```go
func WrapAllRune[T ~string](str T, token string) T
```

## func Zip

```go
func Zip[T any](slices ...[]T) [][]T
```

Zip iteratively merges together the values of the slice parameters with the values at the corresponding position.

## func baseFlatten

```go
func baseFlatten[T any](acc []T, slice any) ([]T, error)
```

## func mapByIndex

```go
func mapByIndex[T1 comparable, T2 any](origSlice []T2, mapSlice []T1) map[T1][]T2
```

MapByIndex

## func splitStringWithDelimiter

```go
func splitStringWithDelimiter[T ~string](str T, delimiter string) T
```

splitStringWithDelimiter splits a string to lower case with the provided delimiter.

## func swap

```go
func swap[T any](a, b *T)
```

swap the two items.

## type Bound

```go
type Bound[T constraints.Signed] struct {
    Min, Max T
}
```

### func \(Bound\[T\]\) Enclose

```go
func (b Bound[T]) Enclose(nth T) bool
```

Enclose checks if an element is inside the bounds.

## type CompFn

CompFn is a generic function type for comparing two values.

```go
type CompFn[T any] func(a, b T) bool
```

## type Memoizer

Memoizer is a two component struct type used to memoize the results of a function execution. It holds an exported Cache storage and a singleflight.Group which is used to guarantee that only one function execution is in flight for a given key.

```go
type Memoizer[T ~string, V any] struct {
    Cache *cache.Cache[T, V]
    group *singleflight.Group
}
```

### func NewMemoizer

```go
func NewMemoizer[T ~string, V any](expiration, cleanup time.Duration) *Memoizer[T, V]
```

NewMemoizer instantiates a new Memoizer.

### func \(Memoizer\[T, V\]\) Memoize

```go
func (m Memoizer[T, V]) Memoize(key T, fn func() (*cache.Item[V], error)) (*cache.Item[V], error)
```

Memoize returns the item under a specific key instantly in case the key exists, otherwise returns the results of the given function, making sure that only one execution is in\-flight for a given key at a time. This method is useful for caching the result of a time consuming operation when is more important to return a slightly outdated result, than to wait for an operation to complete before serving it.

## type Number

Number is a custom type set of constraints extending the Float and Integer type set from the experimental constraints package.

```go
type Number interface {
    constraints.Float | constraints.Integer
}
```

## type RType

RType is a generic struct type used as method receiver on retry operations.

```go
type RType[T any] struct {
    Input T
}
```

### func \(RType\[T\]\) Retry

```go
func (v RType[T]) Retry(n int, fn func(T) error) (int, error)
```

Retry tries to invoke the callback function n times. It runs until the number of attempts is reached or the returned value of the callback function is nil.

### func \(RType\[T\]\) RetryWithDelay

```go
func (v RType[T]) RetryWithDelay(n int, delay time.Duration, fn func(time.Duration, T) error) (time.Duration, int, error)
```

RetryWithDelay tries to invoke the callback function n times, but with a delay between each calls. It runs until the number of attempts is reached or the error return value of the callback function is nil.

## type debouncer

```go
type debouncer struct {
    duration time.Duration
    timer    *time.Timer
    mu       sync.Mutex
}
```

### func \(\*debouncer\) add

```go
func (d *debouncer) add(f func())
```

add method schedules the execution of the passed in function after a predefined delay.

### func \(\*debouncer\) cancel

```go
func (d *debouncer) cancel()
```

cancel the execution of a scheduled debounce function.

## type throttler

The throttle implementation is based on this package: https://github.com/boz/go-throttle.

```go
type throttler struct {
    duration time.Duration
    cond     *sync.Cond
    last     time.Time
    waiting  bool
    trailing bool
    stop     bool
}
```

### func NewThrottle

```go
func NewThrottle(wait time.Duration, trailing bool) *throttler
```

NewThrottle creates a throttled function in order to limit the frequency rate at which the passed in function is invoked. The throttled function comes with a cancel method for canceling delayed function invocation. If the trailing parameter is true, the function is invoked right after the throttled code has been started, but at the trailing edge of the timeout. In this case the code will be executed one more time at the beginning of the next period.

This function is useful for rate\-limiting events that occur faster than you can keep up with.

### func \(\*throttler\) Call

```go
func (t *throttler) Call()
```

Call schedules the execution of the passed in function after the predefined delay.

### func \(\*throttler\) Cancel

```go
func (t *throttler) Cancel()
```

cancel the execution of a scheduled throttle function.

### func \(\*throttler\) Next

```go
func (t *throttler) Next() bool
```

next returns true at most once per time period. It runs until the throttled function is not canceled.



